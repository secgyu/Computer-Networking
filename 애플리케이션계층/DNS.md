# DNS (Domain Name System)

### 호스트 이름(hostname)

인터넷 호스트의 식별자 중 하나는 `www.naver.com`, `www.google.com` 등의 `호스트 이름(hostname)`이다.  
호스트는 흔히 말하는 `IP 주소(IP address)`로 식별된다.

<br/>

### IP 주소(IP address)

IP 주소는 4 바이트로 구성되고, **계층구조를 갖는다.**

- `192.1680.1.114`과 같은 형태로 0 ~ 255의 십진수로 표현하는 각 바이트는 점으로 구분한다.

<br/>

## DNS(Domain Name System)

1. DNS 서버들의 **계층구조**로 구현된 **분산** 데이터 베이스이다.  
   implemented in hierarchy of many name servers

2. 호스트가 분산 데이터 베이스로 질의하도록 허락하는 **애플리케이션 계층 프로토콜**이다.

<br/>

DNS 서버는 주로 BIND(Berkeley Internet Name Domain) 소프트웨어를 수행하는 유닉스(UNIX) 컴퓨터다.

DNS 프로토콜은 `UDP` 상에서 수행되고 `포트 번호 53`을 이용한다.

<br/>

## DNS가 UDP를 사용하는 이유

#### :one: 빠른 속도

TCP의 경우 데이터 전송 시작 전에 3-way-handshaking 과정이 있는 반면, UDP는 연결 설정에 드는 비용이 없다.

> DNS는 신뢰성보다 **속도가 더 중요한 서비스이기 때문에** TCP보다 UDP가 더 적합하다.

<br/>

#### :two: 연결 상태를 유지할 필요가 없다.

TCP는 호스트 간의 연결 상태를 유지한다.

이때 TCP의 패킷 안에는 여러 정보가 담겨 있지만, UDP는 어떤 정보도 기록하지 않고 유지할 필요도 없다.

> DNS 서버는 TCP보다 많은 클라이언트를 수용할 수 있으므로 **연결 상태를 유지하지 않고 정보 기록을 최소화할 수 있는** UDP를 채택하였다.

<br/>

## 사용자의 호스트에서 수행하는 브라우저가 URL을 검색했을 때 발생하는 일

1. 같은 사용자 컴퓨터는 DNS 애플리케이션의 클라이언트를 수행한다.
2. 브라우저는 URL로부터 호스트 이름을 추출하고 그 호스트 이름을 DNS 애플리케이션의 클라이언트에 보낸다.
3. DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하는 질의를 보낸다. (client queries to DNS server)
4. DNS 클라이언트는 결국 호스트 이름에 대한 IP 주소를 받게 된다.
5. 브라우저가 DNS로부터 IP 주소를 받으면,  
   브라우저는 해당 IP 주소와 그 주소의 80번 포트에 위치하는 HTTP 서버 프로세스로 TCP 연결을 초기화한다.

<br/>

DNS는 위 예시에서 알 수 있듯이 추가 지연을 주지만,  
가까운 DNS 서버에 `캐싱`되어 있어서 평균 DNS 지연 뿐만 아니라 DNS 네크워크 트래픽 감소에 도움을 준다.

<br/>

### 호스트 에일리어싱(host aliasing)

복잡한 호스트 이름을 가진 호스트는 하나 이상의 별명을 가질 수 있다.

`relay1.west-coast.enterprise.com` 같은 호스트 이름은 `enterprise.com` 같은 별칭을 가질 수 있다.

이 경우에 `relay1.west-coast.enterprise.com`를 `정식 호스트 이름(canonical hostname)`이라고 한다.

> DNS는 호스트의 IP 주소 뿐만 아니라 제시한 **별칭 호스트 이름에 대한 정식 호스트 이름을 얻기 위해** 이용될 수 있다.

<br/>

### 부하 분산 (load distribution)

> load balancing among the servers

<br/>

## DNS 동작 원리 개요

사용자의 호스트에서 실행되는 어떤 애플리케이션이 호스트 이름을 IP 주소로 변환하려 한다고 가정하자.

과정은 다음과 같다.

1. 애플리케이션이 호스트 이름을 명시하여 DNS 클라이언트 호출한다.
2. 사용자 호스트의 DNS는 네트워크에 질의 메시지를 보낸다.  
   이때 모든 질의와 응답 메시지는 `포트 53의 UDP 데이터그램`으로 보내진다.
3. 응답 메시지를 애플리케이션에 전달한다.

<br/>

DNS는 많은 서버를 이용하고 이들을 계층 형태로 구성하며 전세계에 분산시킨다.


## 계층 DNS 서버의 종류

### 루트(root) DNS 서버

- 1000개 이상의 루트 서버 인스턴스가 세계에 흩어져 있다.
- 루트 네임 서버는 TLD 서버의 IP 주소들을 제공한다.
<br/>

### TLD(최상위 레벨 도메인) DNS 서버

- Top-Level Domain, TLD
- `com`, `org`, `net` 같은 상위 레벨 도메인과 `kr`, `uk` 같은 모든 국가의 상위 레벨 도메인에 대한 TLD 서버가 있다.
- Authoritative(책임) DNS 서버에 대한 IP 주소를 제공한다.

<br/>

### 책임 DNS 서버

- 인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 이름을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야 한다.
    - 기관의 책임 DNS 서버는 이 DNS 레코드를 갖고 있다.
- 기관은 직접 자신의 책임 DNS 서버의 구현을 선택할 수 있고, 일부 서비스 제공자의 책임 DNS 서버에 이 레코드를 저장하도록 비용을 지불한다.

<br/>

### 로컬(local) DNS 서버

- 로컬 DNS 서버는 서버들의 계층 구조에 엄격하게 속하지는 않지만 DNS 구조의 중심에 있다.
- ISP는 로컬 DNS 서버를 갖고, 로컬 DNS 서버로부터 IP 주소를 호스트에게 제공한다.
- 대체로 호스트에 가까이 있기 때문에 지연이 적다.

<br/>

## DNS 캐싱

실제로는 DNS 지연 성능 향상과 네트워크의 DNS 메시지 수를 줄이기 위해 `캐싱(caching)`을 사용한다.

> 질의 사슬에서 **DNS 서버는 DNS 응답을 받았을 때 로컬 메모리에 응답에 대한 정보를 저장할 수 있다.**

<br/>

만약 호스트의 이름과 IP 주소 쌍이 DNS 서버에 저장되고 다른 호스트 이름으로부터 같은 질의가 DNS 서버로 도착한다면,  
DNS 서버는 호스트 이름에 대한 책임이 없을 때조차 원하는 주소를 제공할 수 있다.

호스트 DNS와 IP 사이의 매핑과 호스트는 영구적이지 않기 때문에 어떤 기간(`TTL, Time to Live`) 이후에 저장된 정보를 제거한다.

로컬 DNS 서버는 구체적인 IP 주소 이외에도 TLD 서버의 IP를 저장하여 루트 DNS 서버를 우회할 수 있게 한다.

<br/>

## DNS 레코드

각 DNS는 **하나 이상의 자원 레코드를 가진** 메시지로 응답한다.

## DNS 자원 레코드

DNS 서버들은 호스트 이름을 IP 주소로 매핑하기 위한 `자원 레코드(Resource Records)`를 저장한다.

자원 레코드는 다음과 같은 필드를 포함하는 4개의 Tuple로 되어 있다.

```
Name, Value, Type, TTL
```

`TTL(Time to Live)`은 자원 레코드의 생존 기간이다.

### Type = `A`

> Address  
> Type A 레코드는 표준 호스트 이름의 IP 주소 매핑을 제공한다.

- Name : 호스트 이름(hostname)
- Value : 호스트 이름에 대한 IP 주소

<br/>

### Type = `NS`

> Name Server

- Name : 도메인(domain)
- Value : 도메인 내부의 호스트에 대한 IP 주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 이름

<br/>

### Type = `CNAME`

> Canonical NAME

- Name : 정식 호스트 이름의 alias name
- Value : 별칭 호스트 이름 Name에 대한 정식 호스트 이름

<br/>

### Type = `MX`

> Mail eXchange

- Value : 별칭 호스트 이름 Name을 갖는 메일 서버의 정식 이름
- MX 레코드는 메일 서버의 호스트 이름이 간단한 별칭을 갖는 것을 허용한다.

<br/>

## DNS 취약점

### DDoS 대역폭 플러딩 공격

공격자는 DNS 루트 서버로 다량의 패킷을 보내려는 시도를 하여 다른 DNS 질의들이 응답을 받지 못하게 하려 한다.

실제로 이 일이 일어났지만, 많은 DNS 루트 서버들은 루트 서버로 향하는 공격자가 사용한 ICMP 핑 메시지를 블록하도록 형상화한 패킷 필터로 보호되었고,  
대부분의 로컬 DNS 서버가 최상위 도메인 서버들의 IP 주소들을 캐싱하고 있어서 피해가 거의 없었다.
