# 📡 라우팅 알고리즘 (Routing Algorithms)
라우팅 알고리즘은 네트워크에서 패킷이 목적지까지 도달하는 최적 경로를 찾기 위해 사용됩니다.  
주요 라우팅 알고리즘에는 거리 벡터 라우팅과 링크 상태 라우팅이 있습니다.

## 🗺️ 라우팅 개념
**라우팅 (Routing)**: 송신 측에서 목적지까지 패킷이 전송될 경로를 결정하는 과정입니다.  
**포워딩 (Forwarding)**: 라우터에서 입력 링크로부터 패킷을 받아 출력 링크로 전달하는 과정입니다.  
**포워딩 테이블 (Forwarding Table)**: 목적지 주소를 출력 링크 인터페이스에 대응시킨 테이블입니다.

## 🔄 거리 벡터 라우팅 (Distance Vector Routing)
거리 벡터 라우팅은 각 라우터가 인접 라우터들과 주기적으로 거리 벡터를 교환하여 최단 경로를 찾는 알고리즘입니다.   
벨만-포드(Bellman-Ford) 알고리즘이 사용됩니다.

### 📝 주요 개념
**거리 벡터 (Distance Vector)**: 라우터가 알고 있는 네트워크 내 모든 목적지까지의 거리와 경로 정보를 포함합니다.  
**반복적 갱신**: 라우터는 인접 라우터로부터 거리 벡터를 수신하고 자신의 거리 벡터를 갱신합니다.  
**벨만-포드 수식**: D(x) = min ( cost(x, v) + D(v) )
 - 여기서 D(x)는 노드 x에서 목적지까지의 최소 비용 경로의 비용을 나타내며, cost(x, v)는 노드 x에서 인접 노드 v로의 비용을 나타냅니다.

### 📊 알고리즘 절차
1. **초기화**: 각 라우터는 자신의 초기 거리 벡터를 설정합니다. 초기값으로, 자신에게는 0, 다른 모든 노드에게는 무한대(∞)를 설정합니다.  
2. **거리 벡터 수신**: 인접 라우터로부터 거리 벡터를 수신하면, 이를 이용해 자신의 거리 벡터를 갱신합니다.  
3. **거리 벡터 갱신**: 수신된 거리 벡터 정보를 바탕으로 자신의 거리 벡터를 갱신합니다. 벨만-포드 수식을 이용해 각 목적지까지의 최소 비용을 계산합니다.  
4. **거리 벡터 전송**: 갱신된 거리 벡터를 인접 라우터들에게 전송합니다.  
5. **반복**: 네트워크 내 모든 라우터가 최단 경로를 찾을 때까지 이 과정을 반복합니다.

### 💡 장단점
**장점**: 구현이 간단하고 소규모 네트워크에 적합합니다.  
**단점**: 대규모 네트워크에서 수렴 시간이 길고, 경로 루프 발생 가능성이 있습니다.

## 🔗 링크 상태 라우팅 (Link State Routing)
링크 상태 라우팅은 각 라우터가 네트워크 전체의 링크 상태 정보를 사용하여 최단 경로를 계산하는 알고리즘입니다.   
다익스트라(Dijkstra) 알고리즘이 사용됩니다.

### 📝 주요 개념
**링크 상태 (Link State)**: 라우터와 인접 라우터 간의 링크 상태 정보를 나타냅니다.  
**플러딩 (Flooding)**: 각 라우터는 자신의 링크 상태 정보를 네트워크 내 모든 라우터에게 전송합니다.  
**다익스트라 알고리즘**: 주어진 시작 노드로부터 다른 모든 노드까지의 최단 경로를 찾는 알고리즘입니다.

### 📊 알고리즘 절차
1. **링크 상태 수집**: 각 라우터는 인접 라우터와의 링크 상태 정보를 수집합니다. 각 링크의 비용을 포함한 링크 상태 패킷(LSA, Link State Advertisement)을 생성합니다.  
2. **플러딩**: 링크 상태 정보를 네트워크 내 모든 라우터에게 플러딩합니다. 모든 라우터는 이 정보를 받아 네트워크의 전체 토폴로지를 구성합니다.  
3. **최단 경로 계산**: 다익스트라 알고리즘을 사용하여 최단 경로를 계산합니다. 각 라우터는 자신을 루트로 하는 최단 경로 트리를 형성합니다.  
4. **라우팅 테이블 갱신**: 계산된 최단 경로 정보를 바탕으로 라우팅 테이블을 갱신합니다.

### 💡 장단점
**장점**: 대규모 네트워크에서도 빠르게 수렴하고, 경로 루프가 발생하지 않습니다.  
**단점**: 구현이 복잡하고, 플러딩으로 인한 네트워크 부하가 발생할 수 있습니다.

